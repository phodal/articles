# 构建可信软件系统的 10 要素【draft】

上周，我听公司的咨询同事讲到一个非常有趣的观点：

 - 为什么微服务成本很高，要将单体应用改成微服务？
 - 为什么中台并不能解决问题，但是还是要做中台？
 - 为什么微前端不是银弹，但是我们仍然想做微服务？
 - ……

『因为代码写得烂吧，质量上不去，自然需要找个**好的理由**来重写应用』。旧的代码不好维护，只是其中的一个理由。现在，加上了新的技术、新的架构，已然变成了两个理由了，也就是一个好的理由。

所以，我又想重新思考一下，如何在这方面做得更好。

## 1. 清晰明确的架构远景

白板 + C4Model

## 2. 风格受限的代码规范

清晰整洁的软件代码

我们使用各种 Lint 各种工具

但是我们并没有使用全部力气来做这样的事情，短的函数（如 30 行内，Java 这一类繁琐的语言另说）


### 命名规范

如在后端开发中使用的 [https://www.cnblogs.com/davenkin/p/spring-boot-template.html]：

 - 客户端的请求数据类统一使用相同后缀，比如Command
 - 返回给客户端的数据统一使用相同后缀，比如Represetation

对于前端来说，对应的可能是：

 - 请求服务端使用相同后缀，如 Request
 - 处理返回端返回的结果，如 Response

## 3. 自动守护的分层架构

分层架构

事实上，不论我们做出怎样的架构决策，在当前的技术**『树型目录结构』决定了落地架构必是『分层架构』**。

分层架构水平拆分方式：

```
domain
 - services
 - controller
 - infrastructure
```

演变为按业务拆分，即水平 + 垂直的分包方式。

 - ArchUnit

架构守护，


## 4. 人机共存的代码检视

人都是不靠谱的。而对于 Code Review 这种团体活动来说，人越是多，那么反而 review 的效果就不上去。

而机呢，是指依赖于 SonarQube 这一类的自动化工具来实施。

## 5. 测试保证的关键逻辑

测试会带来成本，但是会提升软件质量。

## 6. 工具约束的开发流程

人都是不可信的。所以，在我最近经历的项目中，都无一例外地引入  pre-push，pre-commit 这样的流程，但是它仍然是可以跳过的。

## 7. 动态更新 + 文档策略

项目文档 + 部署文档 + 可视化文档 + 架构演进文档


如我司大佬滕云在 《[后端开发实践系列之一 —— Spring Boot项目模板](https://www.cnblogs.com/davenkin/p/spring-boot-template.html)》 所说一个合理的 README 应该包含：

 - 项目简介：用一两句话简单描述该项目所实现的业务功能；
 - 技术选型：列出项目的技术栈，包括语言、框架和中间件等；
 - 本地构建：列出本地开发过程中所用到的工具命令；
 - 领域模型：核心的领域概念，比如对于示例电商系统来说有Order、Product等；
 - 测试策略：自动化测试如何分类，哪些必须写测试，哪些没有必要写测试；
 - 技术架构：技术架构图；
 - 部署架构：部署架构图；
 - 外部依赖：项目运行时所依赖的外部集成方，比如订单系统会依赖于会员系统；
 - 环境信息：各个环境的访问方式，数据库连接等；
 - 编码实践：统一的编码实践，比如异常处理原则、分页封装等；
 - FAQ：开发过程中常见问题的解答。

Path to Production + ADR + Wiki 


## 8. 独立巧妙的系统划分

单体应用正在杀死

服务划分 + 应用内划分


我本是想说微服务，可微服务只是划分方式的一种，

## 9. 持续偿还的技术债务

### 与时俱进的依赖更新

依赖依旧是重要的一环。

## 10. 强有力的个人 & 愿意改进的团队

虽然我想说 KPI，但是 KPI 反而是有害的——上有政策，下有对策。只要了解或者是熟悉评分的标准，那么就可以有针对性的进行**负优化**，比如说用代码行数来评定绩效。

## 结论

不过，话说回来，国内的程序员便宜，所以架构并不是考量因素——并且找 10 个程序员来重写，反而比找一个优秀的程序员更加容易。可维护的架构也就没有成为国内程序员的挑战，业务的快速推进才是重中之中。但是呢，这个情况并不会再持续太久。

而无论怎样，好的架构都需要强有力的个人和愿意改进的团队。

